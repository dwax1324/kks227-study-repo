https://blog.naver.com/kks227/220785747864

### 이론


```
Breadth-First-Search(BFS)

DFS와 달리 BFS는 넓이를 중시한다.
BFS는 모든 곳을 조금조금씩 판다.


각 단계의 정점들은 그 단계 안에서 방문 순서가 바뀔 수는 있지만, 다른 단계와 방문 순서가 절대 뒤섞이지 않는다.
즉, k단계에 방문하는 정점들은 시작점으로부터 최단거리가 k이다.

최단거리란, A에서 B로가는데 필요한 최소 개수의 간선(가중치가 없을경우)이다.



그래프가
              0
            /   \
           1     2
          / \   / \
         3   5 6 - 8
          \ /   \
           4    7

일때,

기본적인 BFS코드 👇

```

```cpp

#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
 
class Graph{
public:
    int N; // 정점의 개수
    vector<vector<int>> adj; // 인접 리스트
 
    // 생성자
    Graph(): N(0){}
    Graph(int n): N(n){ adj.resize(N); }
 
    // 간선 추가 함수
    void addEdge(int u, int v){
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
 
    // 모든 리스트의 인접한 정점 번호 정렬
    void sortList(){
        for(int i=0; i<N; i++)
            sort(adj[i].begin(), adj[i].end());
    }
 
    // 너비 우선 탐색
    void bfs(){
        vector<bool> visited(N, false); // 방문 여부를 저장하는 배열
        queue<int> Q;
        Q.push(0);
        visited[0] = true;
        // 탐색 시작
        while(!Q.empty()){
            int curr = Q.front();
            Q.pop();
            cout << "node " << curr << " visited" << endl;
            for(int next: adj[curr]){
                if(!visited[next]){
                    visited[next] = true;
                    Q.push(next);
                }
            }
        }
    }
};
 
int main(){
    Graph G(9);
    G.addEdge(0, 1);
    G.addEdge(0, 2);
    G.addEdge(1, 3);
    G.addEdge(1, 5);
    G.addEdge(3, 4);
    G.addEdge(4, 5);
    G.addEdge(2, 6);
    G.addEdge(2, 8);
    G.addEdge(6, 7);
    G.addEdge(6, 8);
    G.sortList();
    G.bfs();
}
[출처] 너비 우선 탐색(Breadth-First Search) (수정 2018-11-22)|작성자 라이

```

```
결과:
node 0 visited
node 1 visited
node 2 visited
node 3 visited
node 5 visited
node 6 visited
node 8 visited
node 4 visited
node 7 visited

BFS로 시작점부터 각 노드까지의 거리를 알아내는 코드 👇

```

``` cpp
  // 너비 우선 탐색
    void bfs(){
        vector<bool> visited(N, false); // 방문 여부를 저장하는 배열
        queue<int> Q;
        Q.push(0);
        visited[0] = true;
 
        // 탐색 시작
        int level = 0;
        while(!Q.empty()){
            int qSize = Q.size();
            cout << "------ level " << level << " ------" << endl;
            for(int i=0; i<qSize; i++){
                int curr = Q.front();
                Q.pop();
                cout << "node " << curr << " visited" << endl;
                for(int next: adj[curr]){
                    if(!visited[next]){
                        visited[next] = true;
                        Q.push(next);
                    }   
                }
            }
            level++;
        }
    }
[출처] 너비 우선 탐색(Breadth-First Search) (수정 2018-11-22)|작성자 라이

```

```
결과:
------ level 0 ------
node 0 visited
------ level 1 ------
node 1 visited
node 2 visited
------ level 2 ------
node 3 visited
node 5 visited
node 6 visited
node 8 visited
------ level 3 ------
node 4 visited
node 7 visited
```

### 문제

* [1260번: DFS와 BFS](https://www.acmicpc.net/problem/1260)
* [2644번: 촌수계산](https://www.acmicpc.net/problem/2644)
* [2178번: 미로 탐색](https://www.acmicpc.net/problem/2178)
* [6593번: 상범 빌딩](https://www.acmicpc.net/problem/6593)
* [5427번: 불](https://www.acmicpc.net/problem/5427)
* [3055번: 탈출](https://www.acmicpc.net/problem/3055)
* [2206번: 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)
* [7576번: 토마토](https://www.acmicpc.net/problem/7576)
* [7562번: 나이트의 이동](https://www.acmicpc.net/problem/7562)
* [5014번: 스타트링크](https://www.acmicpc.net/problem/5014)
* [1697번: 숨바꼭질](https://www.acmicpc.net/problem/1697)
* [16397번: 탈출](https://www.acmicpc.net/problem/16397)
* [9019번: DSLR](https://www.acmicpc.net/problem/9019)
* [1525번: 퍼즐](https://www.acmicpc.net/problem/1525)
* [1039번: 교환](https://www.acmicpc.net/problem/1039)



<!-- 

***

<details>

<summary>

6593번: 상범 빌딩

</summary>

</details> 



-->



<details>

<summary>

#### _1260번: DFS와 BFS_

basic
</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
// #define int int64_t
/* ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾
    2020.01.06 Wed
    comment: 

⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾*/

int n,m,k;
vector<int> arr[1001];
bool vi[1001];
void dfs(int start){
    vi[start] =true;
    cout << start +1 << " ";
    for(int i=0; i < arr[start].size(); i++){
        int next = arr[start][i];
        if(!vi[next]){
            dfs(next);
        }
    }
}

void bfs(int start){
    vi[start] = true;
    queue<int> q;
    q.push(start);

    while(q.size()){
        int cur = q.front();
        cout << cur +1 << " ";
        q.pop();
        for(int i=0; i < arr[cur].size(); i++){
            int next = arr[cur][i];
            if(!vi[next]) {
                q.push(next);
                vi[next] =true;
            }
        }

    }

}


void solve(){
    cin >> n >> m >> k;
    k--;
    for(int i=0; i < m; i++){
        int u,v;
        cin >> u >>v;
        u--;v--;
        arr[u].push_back(v);
        arr[v].push_back(u);
    }

    for(int i=0; i < n; i++){
        sort(all(arr[i]));
    }

    dfs(k);
    cout << '\n';
    memset(vi,0,sizeof(vi));
    bfs(k);

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```
</details> 


***

<details>

<summary>

#### _2644번: 촌수계산_

시작지점에서 bfs돌리면 된다.  
bfs가 돌아가는 중에 끝지점을 못만나면 컴포넌트가 다르므로 -1을 출력한다.
</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
// #define int int64_t
/* ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾
    2020.01.06 Wed
    comment: 

⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾*/

vector<int> arr[101];
int dist[101];
void solve(){
    int n;
    int s,e;
    int m;
    cin >> n >> s >> e >> m;
    for(int i=0; i < m; i++){
        int x,y;
        cin >> x >> y;
        arr[x].push_back(y);
        arr[y].push_back(x);
    }

    queue<int> q;
    memset(dist,-1,sizeof(dist));
    q.push(s);
    dist[s]= 0;
    while(q.size()){
        int cur = q.front();
        q.pop();
        for(int i=0; i < arr[cur].size(); i++){
            int next = arr[cur][i];
            if(dist[next] == -1){
                q.push(next);
                dist[next] = dist[cur]+1;
            }
        }
    }
    cout << dist[e];
    

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}



```

</details> 


***

<details>

<summary>

#### _2178번: 미로 탐색_

간단 2차원 bfs

</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
// #define int int64_t
/* ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾
    2020.01.06 Wed
    comment: 

⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾*/

char arr[101][101];
int dist[101][101];
struct coords{
    int y,x;
};

void solve(){
    int n,m;
    cin >> n>> m;
    for(int i=0; i < n; i++)
        for(int j=0; j < m ;j++)
            cin >> arr[i][j];
    
    queue<coords> q;
    q.push({0,0});

    memset(dist,-1,sizeof(dist));
    dist[0][0] = 1;
    while(q.size()){
        coords cur = q.front();
        q.pop();
        for(int i=0; i < 4; i++){
            int ny = cur.y + "2011"[i] -'1';
            int nx = cur.x + "1102"[i]-'1';
            if(ny <0 || nx <0 || ny >= n || nx >= m) continue;
            if(dist[ny][nx] != -1) continue;
            if(arr[ny][nx] == '0') continue;
            q.push({ny,nx});
            dist[ny][nx] = dist[cur.y][cur.x]+1;
        }
    }

    cout << dist[n-1][m-1];


    

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}


```

</details> 


***

<details>

<summary>

#### _6593번: 상범 빌딩_

3차원 bfs

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
// #define int int64_t
/* ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾
    2020.01.06 Wed
    comment: 

⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾ ⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾*/

char map1[31][31][31];
int dist[31][31][31];
struct coords{
    int l,r,c;
};
int dx[6] = { 1, -1, 0, 0 , 0, 0};
int dy[6] = { 0, 0, 1, -1, 0 ,0};
int dz[6] = { 0, 0, 0, 0, 1, -1};

void solve(){

    int L,R,C;
    while(1){
        cin >> L >> R >> C;
        if(L==0 && R == 0 && C ==0) break; 
        queue<coords>q;
        coords end,start;
        for(int i=0; i < L ; i++)
            for(int j=0; j < R; j++)
                for(int k=0; k< C; k++){
                    cin >> map1[i][j][k];
                    if(map1[i][j][k] == 'S') start = {i,j,k};
                    if(map1[i][j][k] == 'E') end= {i,j,k};
                }
        
        q.push(start);
        memset(dist,-1,sizeof(dist));
        dist[start.l][start.r][start.c] = 0;

        while(q.size()){
            coords cur = q.front();
            q.pop();
            for(int i=0; i < 6; i++){
                int nl = cur.l + dz[i];
                int ny = cur.r + dy[i];
                int nx = cur.c + dx[i];
                if(nl <0 || ny <0 || nx <0 || nl >= L || ny >= R || nx >= C) continue;
                if(map1[nl][ny][nx] == '#') continue;
                if(dist[nl][ny][nx] != -1) continue;
                q.push({nl,ny,nx});
                dist[nl][ny][nx] = dist[cur.l][cur.r][cur.c] +1;
            }
        }
        (dist[end.l][end.r][end.c] == -1) ? (cout << "Trapped!\n") : (cout << "Escaped in " << dist[end.l][end.r][end.c] << " minute(s).\n");
    }
}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}



```

</details> 