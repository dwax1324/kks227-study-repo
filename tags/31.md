# ê°•í•œ ì—°ê²° ìš”ì†Œ(Strongly Connected Component)

https://blog.naver.com/kks227/220802519976

### ì´ë¡ 

```
ê·¸ë˜í”„ë¥¼ ì••ì¶•ì‹œí‚¤ëŠ” ë°©ë²•.

a â†” b â†’ c â†” d
â†‘ â†™ â†“   â†“   â†•
e â†’ f â†” g â† h

ì´ëŸ° ê·¸ë˜í”„ê°€ ìˆë‹¤ê³  í•˜ì.
SCCëŠ” ì¼ì¢…ì˜ ì„œë¸Œ ê·¸ë˜í”„ì¸ë°, í•˜ë‚˜ì˜ SCCì•ˆì— ìˆëŠ” ì–´ë–¤ ë‘ ì •ì 
u,vë¥¼ ê³¨ë¼ë„, SCCì•ˆì—ì„œ u->v ë¡œ ê°€ëŠ” ì§/ê°„ì ‘ì  ê²½ë¡œê°€ ì¡´ì¬í•œë‹¤.

ë˜í•œ, SCCëŠ” maximalí•œ ì„±ì§ˆì„ ê°–ëŠ”ë‹¤.
SCCëŠ” ê°€ëŠ¥í•œ ì»¤ì•¼í•œë‹¤ëŠ” ëœ»ì´ë‹¤.

ì˜ˆë¥¼ë“¤ì–´, ì˜¤ë¥¸ìª½ì˜ SCCì¸{c,d,h}ì˜ í•˜ìœ„ ì§‘í•©ì¤‘ {c,d}ì—­ì‹œ SCCì˜
ì²«ë²ˆì§¸ ì„±ì§ˆì€ ë§Œì¡±í•˜ì§€ë§Œ, ì—¬ê¸°ì— ì •ì  hë¥¼ ë” ì¶”ê°€í•´ë„ ì—¬ì „íˆ ì„±ì§ˆì´
ë§Œì¡±ë˜ë¯€ë¡œ hëŠ” ë°˜ë“œì‹œ ì¶”ê°€ë˜ì–´ ìˆì–´ì•¼í•œë‹¤.

ì´ë ‡ê²Œ ìœ í–¥ê·¸ë˜í”„ê°€ ì£¼ì–´ì§€ë©´ íŒŒí‹°ì…˜ ë¶„í• í•˜ì—¬ ê°ê° SCCê°€ ë˜ê²Œ ë§Œë“œëŠ” ê²ƒì´ í•­ìƒê°€ëŠ¥í•˜ê³ ,
ì„ í˜•ì‹œê°„, ì¦‰ O(N)ì•ˆì— ëª¨ë“  SCCë¥¼ ë¶„ë¦¬í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ë‹¤.

ì¼ë‹¨ ìœ„ ê·¸ë˜í”„ì—ì„œ {a,b,e}, {c,d,h},{f,g} ê°ê°ì´ SCCì´ê³ ,
ê° SCCëª¨ë‘ ë‘ê°€ì§€ ì„±ì§ˆ( SCC ë‚´ì˜ u->vë¡œ ê°€ëŠ” ê²½ë¡œ, maximalí•œ ì„±ì§ˆ)
ì‹¸ì´í´ì„ ì´ë£¨ëŠ” ì •ì ë“¤ ì‚¬ì´ì—ì„œë„ ì„œë¡œ í•­ìƒ ë„ë‹¬ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì„±ì§ˆì´ ì¡´ì¬í–ˆëŠ”ë°,
SCCëŠ” ì‹¸ì´í´ë³´ë‹¤ë„ ìƒìœ„ì˜, ë”  í¬ê´„ì ì¸ ê°œë…ì´ë¼ê³  ë³¼ ìˆ˜ ìˆê² ë‹¤.
{a,b,e}ë‚˜ {f,g}ë§Œ ë–¼ì–´ë†“ê³  ë³´ë©´ ë‹¨ìˆœ ì‹¸ì´í´ì¸ë°, {c,d,h} ê·¸ë ‡ì§€ë§Œë„ ì•Šë‹¤.

ìœ í–¥ê·¸ë˜í”„ì—ì„œë§Œ ì´ ìš©ì–´ê°€ í†µìš©ëœë‹¤.
ë¬´í–¥ê·¸ë˜í”„ì˜€ë‹¤ë©´ ì»´í¬ë„ŒíŠ¸ ìì²´ê°€ SCCë‹¤. ë³„ë¡œ ì˜ë¯¸ê°€ ì—†ì–´ì§„ë‹¤.

íƒ€ì”(Robert Tarjan) ì•Œê³ ë¦¬ì¦˜

í•œë²ˆì˜ DFSì™€ ë³„ë„ì˜ ìŠ¤íƒì„ ì´ìš©í•˜ì—¬ SCCë“¤ì„ ë¶„ë¦¬í•´ë‚¸ë‹¤.

ê·¸ë¦¼ë„ˆë¬´ë§ì•„ì„œ ëª»ê·¸ë¦¬ê² ìŒã… ã… 

ìš©ì–´ì •ë¦¬


DFSíŠ¸ë¦¬ë€ ì–´ë–¤ ì •ì ë¶€í„° DFSë¡œë°©ë¬¸í–ˆì„ë•Œ ìƒê¸°ëŠ” íŠ¸ë¦¬
íŠ¸ë¦¬ê°„ì„ (tree edge)ë€ DFSíŠ¸ë¦¬ìƒì— ì¡´ì¬í•˜ëŠ” ê°„ì„ ì´ë‹¤.
ìˆœë°©í–¥ê°„ì„ (forward edge)ë€ ìì‹ ì˜ ìì† ë…¸ë“œë¡œ ê°€ëŠ¥ ê°„ì„ ì´ë‹¤.
ì—­ë°©í–¥ê°„ì„ (back edge)ë€ ìì‹ ì˜ ì¡°ìƒ ë…¸ë“œë¡œ ê°€ëŠ” ê°„ì„ ì´ë‹¤.
êµì°¨ê°„ì„ (cross edge)ë€ ê·¸ì™¸ ê°„ì„ ì´ë‹¤

ê° ì •ì ì— ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ dfsnì„ 1ì”© ì¦ê°€ì‹œí‚¤ë©° ìƒˆê¸´ë‹¤.
ì²˜ìŒì—” dfsnê°’ì´ -1ë“±ìœ¼ë¡œ ì´ˆê¸°í™” ë˜ì–´ ìˆì–´ì„œ visited ë°°ì—´ê³¼ ê°™ì€ ì—­í• ì„ í•œë‹¤.
ë˜í•œ ë³„ë„ë¡œ SCCì¶”ì¶œì´ ëë‚œ í›„ trueê°€ ë˜ëŠ” finishedë°°ì—´ë„ í•„ìš”í•˜ë‹¤.
DFSë¡œ ì‹¸ì´í´ ì°¾ê¸° ë¬¸ì œë¥¼ í’€ë•Œì™€ ë¹„ìŠ·í•˜ë‹¤. í•˜ì§€ë§Œ DFSë¡œ ì‹¸ì´í´ì„ ì°¾ì„ë•ŒëŠ”
ë°©ë¬¸ì´ ëë‚  ë•Œ finishedê°€ trueê°€ ëì—ˆë‹¤.
íƒ€ì”ì•Œê³ ë¦¬ì¦˜ì€ ê±°ê¸°ì— ë”í•´ ìŠ¤íƒì´ í•˜ë‚˜ ë” í•„ìš”í•˜ë‹¤.
DFSë¡œ ì •ì ì„ ë°©ë¬¸í•  ë•Œë§ˆë‹¤ ìì‹ ì„ pushí•´ë‘”ë‹¤.

ê° ì •ì ì„ DFSë¡œ ë°©ë¬¸í•˜ë©´ì„œ SCCë¥¼ ë½‘ëŠ”ë‹¤.
<"ìì‹  ìì†ë“¤ì´ ìì‹ ì˜ ì¡°ìƒìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ê°€ í•˜ë‚˜ë„ ì—†ì„ ê²½ìš°",
ìì‹ ì„ í¬í•¨í•œ í•˜ë‚˜ì˜ SCCê°€ ë°œê²¬ëœë‹¤.>

SCCê°€ ë°œê²¬ë˜ë©´ ìŠ¤íƒì—ì„œ ìì‹ , ìì‹ ë³´ë‹¤ ìœ„ì— ìˆëŠ” ì •ì ì„ ëª¨ë‘ ë½‘ì•„ì„œ í•˜ë‚˜ì˜ SCCë¥´ ë¬¶ëŠ”ë‹¤.

ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê²ƒì€ "ìì‹ ë³´ë‹¤ ì¡°ìƒì •ì ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠëƒ?"ì´ê³ ,
ì´ ë•Œë¬¸ì— <ìˆœë°©í–¥ê°„ì„ >ì€ í•„ìš”ê°€ ì—†ë‹¤.

ì—­ë°©í–¥ ê°„ì„œì´ ë„ë‹¬í•˜ëŠ” ì •ì ì€ DFS íŠ¸ë¦¬ìƒì—ì„œ ìì‹ ì˜ ì¡°ìƒì´ë¯€ë¡œ
ì•„ì§ ë°©ë¬¸í•¨ìˆ˜ê°€ ì•ˆëë‚¬ê¸° ë–„ë¬¸ì´ë‹¤.
ìì‹ ì˜ ìì‹ë“¤ì˜ ë°©ë¬¸ì´ ë‹¤ ëë‚˜ì•¼ ìì‹ ë„ ëë‚œë‹¤.
ë”°ë¼ì„œ ì—­ë°©í–¥ ê°„ì„ ì´ ë°©ë¬¸í•˜ê²Œ ë˜ëŠ” ì¡° ë…¸ë“œì˜ finishedê°’ì€ falseê°€ ëœë‹¤.
ìˆœë°©í–¥ê°„ì„ ì€ ì•„ë¬´ëŸ° ì¡°ì‘ë„ ê°€í•˜ì§€ ì•Šê³  ë¬´ì‹œí•œë‹¤.

ì—­ë°©í–¥ê°„ì„ ì€ í˜„ì¬ ì •ì ì´ uì´ê³  ë°©ë¬¸í•˜ë ¤ëŠ” ì •ì  vì¼ë•Œ,
visited[v] = trueì´ê³  finished[v] = falseë©´(u,v)ê°€ ì—­ë°©í–¥ ê°„ì„ ì´ë‹¤.
ì—¬ê¸°ì„œëŠ” dfsnì´ë¼ëŠ” ê°’ì„ ì¶”ê°€ë¡œ ì“°ê³ ìˆê¸° ë–„ë¬¸ì—, dfsn[v]ê°’ì´ ìˆëŠ”ì§€ ëŒ€ì‹  ë´ë„ ëœë‹¤.

<SCCë¥¼ ë½‘ê¸° ì‹œì‘í•˜ëŠ” ì¡°ê±´ì€ ìì‹ , ìì‹ ì˜ ìì†ë“¤ ì¤‘ì—ì„œ ìì‹ ì˜
ì¡°ìƒìœ¼ë¡œ ê°€ëŠ” ê²½ë¡œê°€ í•˜ë‚˜ë„ ì—†ì„ë•Œ>ì´ë‹¤.

êµì°¨ ê°„ì„ ì„ ë¬´ì‹œí•´ë„ ì¢‹ì€ ì´ìœ ëŠ”
ì´ë¯¸ SCCë¶„ë¦¬ê°€ ëë‚œ ì •ì ì— ê°ˆìˆ˜ ìˆë‹¤ í•˜ë”ë¼ë„,
ê·¸ìª½ì—ì„œ ì´ìª½ìœ¼ë¡œ ì˜¤ëŠ” ê²½ë¡œê°€ ì—†ê³  ì´ìª½ì—ì„œ ê·¸ìª½ìœ¼ë¡œë§Œ ê°ˆ ìˆ˜ ìˆëŠ”
ì¼ë°©í–¥ì´ë¼ ë‘˜ì´ ê°™ì€ SCCì— ì†í•  ìˆ˜ê°€ ì—†ë‹¤.

í•˜ì§€ë§Œ êµì°¨ê°„ì„  ë–„ë¬¸ì— ì–‘ ìª½ ì •ì ì´ ê°™ì€ SCCì•ˆì— ì†í• ìˆ˜ë„ ìˆë‹¤.
ê·¸ ê²½ìš°ëŠ” í˜„ì¬ ì •ì  u, ë°˜ëŒ€í¸ ì •ì  vì— ëŒ€í•´ finished[v] = falseì¸
ê²½ìš°ë‹¤. ë§Œì•½ finished[v] = trueë¼ë©´ ì´ë¯¸ vëŠ” ìì‹ ì´ ì†í•œ sccê°€
ê²°ì •ë˜ì—ˆê¸° ë–„ë¬¸ì— ì•„ì§ ê²°ì •ë˜ì§€ ì•Šì€ uì™€ ê°™ì€ SCCì— ì†í• ìˆ˜ ì—†ë‹¤.
ë”°ë¼ì„œ finished[v] = trueì¸ ê²½ìš°ë¥¼ ë¬´ì‹œí•˜ë©´ ì´ ë¬¸ì œê°€ ê°„ë‹¨íˆ í•´ê²°ëœë‹¤.

ë‹¨ í•œë²ˆì˜ DFSë¡œ SCCë¶„ë¦¬ê°€ ê°€ëŠ¥í•˜ê³ ,
ì‹œê°„ë³µì¡ë„ëŠ” O(V+E)ë‹¤.


```

### ë¬¸ì œ


* [2150ë²ˆ: Strongly Connected Component](https://www.acmicpc.net/problem/2150)  
* [6543ë²ˆ: The Bottom of a Graph](https://www.acmicpc.net/problem/6543)  
* [4196ë²ˆ: ë„ë¯¸ë…¸](https://www.acmicpc.net/problem/4196)  
* [3977ë²ˆ: ì¶•êµ¬ ì „ìˆ ](https://www.acmicpc.net/problem/3977)  
* [2152ë²ˆ: ì—¬í–‰ ê³„íš ì„¸ìš°ê¸°](https://www.acmicpc.net/problem/2152) 
* [4013ë²ˆ: ATM](https://www.acmicpc.net/problem/4013)   
* [11097ë²ˆ: ë„ì‹œ ê³„íš (â˜…)](https://www.acmicpc.net/problem/11097)  
* [1108ë²ˆ: ê²€ìƒ‰ ì—”ì§„ (â˜…)](https://www.acmicpc.net/problem/1108)   
* [6264ë²ˆ: Sub-dictionary (â˜…)](https://www.acmicpc.net/problem/6264)   

<!-- 

***

<details>

<summary>

#### _4013ë²ˆ: ATM_

</summary>

```cpp

```

</details> 


-->

***

<details>

<summary>

#### _2150ë²ˆ: Strongly Connected Component_

SCC ê¸°ë³¸ ë¬¸ì œ

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
typedef pair<int,int> pii;
typedef tuple<int,int,int> tiii;
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.27 Wed
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

// SN : SCC ê°œìˆ˜, sn[i] : iê°€ ì†í•œ SCCì˜ ë²ˆí˜¸
const int MAX = 10000;
int V,E,cnt,dfsn[MAX],SN,sn[MAX];
vector<int> adj[MAX];
bool finished[MAX]; // SCC ë¶„ë¦¬ê°€ ëë‚œ ì •ì ë§Œ true
stack<int> S;
vector<vector<int>> SCC;

// ìì‹ ì˜ ê²°ê³¼ê°’ì„ ë¦¬í„´í•˜ëŠ” DFSí•¨ìˆ˜

int DFS(int curr){
    dfsn[curr] = ++cnt; // dfnsì„ ê²°ì •
    S.push(curr); // ìŠ¤íƒì— ìì‹ ì„ push

    // ìì‹ ì˜ dfsn, ìì‹ë“¤ì˜ ê²°ê³¼ë‚˜ dfsn ì¤‘ ê°€ì¥ ì‘ì€ ë²ˆí˜¸ë¥¼ resultì— ì €ì¥
    int result = dfsn[curr];
    for(auto next: adj[curr]){
        // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì´ì›ƒ
        if(dfsn[next] == 0) result = min(result,DFS(next));
        // ë°©ë¬¸ì€ í–ˆìœ¼ë‚˜ ì•„ì§ SCCë¡œ ì¶”ì¶œë˜ì§€ ì•Šì€ ì´ì›ƒ
        else if(!finished[next]) result = min(result,dfsn[next]);
    }

    // ìì‹ ,ìì‹ ì˜ ìì†ë“¤ì´ ë„ë‹¬ ê°€ëŠ¥í•œ ì œì¼ ë†’ì€ ì •ì ì´ ìì‹ ì¼ ê²½ìš° SCC ì¶”ì¶œ
    if(result == dfsn[curr]) {
        vector<int> currSCC;
        // ìŠ¤íƒì—ì„œ ë‚˜ì˜¬ë•Œê¹Œì§€ pop
        while(1){
            int t= S.top();
            S.pop();
            currSCC.push_back(t);
            finished[t] = true;
            // sn[t] = SN;
            if(t== curr) break;
        }
        SCC.push_back(currSCC);
        // SN++;
    }
    return result;
}

bool cmp(vector<int> v1, vector<int>v2){ return *min_element(all(v1)) < *min_element(all(v2));}

void solve(){
    cin >> V>> E;
    for(int i=0; i < E; i++){
        int A,B; cin >> A>> B; A--;B--;
        adj[A].push_back(B);
    }

    // DFSë¥¼ í•˜ë©° SCC ì¶”ì¶œ

    for(int i=0; i< V; i++)
        if(dfsn[i] == 0 ) DFS(i);
    
    sort(all(SCC),cmp);
    cout << SCC.size() << '\n';
    for(auto currSCC : SCC){
        sort(all(currSCC));
        for(auto curr: currSCC){
            cout << curr+1 << ' ';
        }
        cout << -1 << '\n';
    }

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 


***

<details>

<summary>

#### _6543ë²ˆ: The Bottom of a Graph_

SCC ì¶”ì¶œí›„ outdegree ì˜ ê°¯ìˆ˜ëŠ” ì„¸ëŠ” ë¬¸ì œ

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
typedef pair<int,int> pii;
typedef tuple<int,int,int> tiii;
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.27 Wed
    comment: 
    SCCì˜ outdegreeì„¸ëŠ” ë¬¸ì œ
    ì§€ë¬¸ì€ ì´í•´ ëª»í•˜ê²Ÿë”°.
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX =5001;
int N,M,SN,sn[MAX],cnt,finished[MAX],dfsn[MAX];
vector<int> adj[MAX];
stack <int> stk;

int tarzan(int curr){

    stk.push(curr);
    int ret = dfsn[curr] = ++cnt;

    for(auto next : adj[curr]){
        if(dfsn[next] ==0) ret= min(ret,tarzan(next));
        else if(finished[next] ==0) ret = min(ret,dfsn[next]);
    }

    if(ret == dfsn[curr]){
        while(1){
            int t = stk.top(); stk.pop();
            sn[t] = SN;
            finished[t] = true;
            if(t == curr) break;
        }
        SN++;
    }
    return ret;
}


void solve(){
    while(1){
        SN=cnt=0;
        cin >> N;
        if(N ==0) break;
        for(int i=0; i < N; i++){
            adj[i].clear();
            dfsn[i] = finished[i] = 0;
        }
        cin >> M;
        for(int i=0; i < M; i++){
            int u,v; cin >> u >> v; u--;v--;
            adj[u].push_back(v);
        }

        for(int i=0; i < N; i++){
            if(dfsn[i] == 0) tarzan(i);
        }
        int indegree[MAX] = {0};

        for(int i=0; i < N; i++){
            for(auto j : adj[i]){
                if(sn[i] != sn[j]) indegree[sn[i]]++;
            }
        }

        for(int i =0; i < N; i++){
            if(indegree[sn[i]] == 0 ) cout << i+1  << " ";
        }
        cout << '\n';


    }


}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _4196ë²ˆ: ë„ë¯¸ë…¸_

SCC ì¶”ì¶œí›„ indegree ì˜ ê°¯ìˆ˜ëŠ” ì„¸ëŠ” ë¬¸ì œ 

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
typedef pair<int,int> pii;
typedef tuple<int,int,int> tiii;
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.27 Wed
    comment: 
    ê°•í•œê²°í•©ìš”ì†Œ SCC
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX = 100001;
int N,M,dfsn[MAX],finished[MAX],sn[MAX],SN,cnt;
vector<int> adj[MAX];
stack<int> stk;
int tarzan(int curr){

    stk.push(curr);
    dfsn[curr] = ++cnt;
    int res = dfsn[curr];

    for(auto next : adj[curr]){
        if(!dfsn[next]) res = min(res,tarzan(next));
        else if(!finished[next]) res = min(res,dfsn[next]);
    }

    if(dfsn[curr] == res){

        while(1){
            int t = stk.top(); stk.pop();
            finished[t] = true;
            sn[t] = SN;
            if(t== curr) break;
        }
        SN++;
    }
    return res;
}

void solve(){
    int T; cin >> T; while(T--){
        
        memset(adj,0,sizeof(adj));
        memset(finished,0,sizeof(finished));
        memset(sn,0,sizeof(sn));
        memset(dfsn,0,sizeof(dfsn));
        cnt=SN= 0;
        cin >> N>> M;
        for(int i=0; i < M ;i++){
            int u,v; cin >> u >> v; u--;v--;
            adj[u].push_back(v);
        }
        for(int i=0; i < N; i++){
            if(dfsn[i] ==0) tarzan(i);
        }

        int indegree[MAX] ={0};

        for(int i=0 ; i < N ; i++){
            for(auto j : adj[i])
                if(sn[i] != sn[j]) indegree[sn[j]]++;
        }
        int ans =0;
        for(int i=0; i < SN;i++){
            if(indegree[i] == 0) ans++;
        }
        cout << ans << '\n';

    }


}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _3977ë²ˆ: ì¶•êµ¬ ì „ìˆ _



SCCì˜ indegree ë¬¸ì œ  
classë¡œ ì§œë´¤ë‹¤  

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
typedef pair<int,int> pii;
typedef tuple<int,int,int> tiii;
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.27 Wed
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/


class FieldPlan{
public:
    static const int MAX = 100001;
    int N,M;
    int dfsn[MAX],SN,cnt,sn[MAX],finished[MAX],indegree[MAX];
    vector<int> adj[MAX];
    stack<int> stk;

    void input(){
        cin >> N>> M;
        for(int i=0; i < N; i++){
            sn[i] = finished[i] = indegree[i] = dfsn[i] =0;
            adj[i].clear();
        }
        SN=cnt=0;
        for(int i=0; i < M; i++){
            int u,v; cin >> u >> v;
            adj[u].push_back(v);
        }
    }

    int tarzan(int curr){
        stk.push(curr);
        int ret = dfsn[curr] = ++cnt;

        for(auto next : adj[curr]){
            if(dfsn[next] == 0) ret = min(ret, tarzan(next));
            else if(finished[next] ==0) ret =min(ret,dfsn[next]);
        }

        if(ret == dfsn[curr]){
            while(1){
                int t = stk.top(); stk.pop();
                sn[t] = SN;
                finished[t]= true;
                if(t == curr) break;
            }
            SN++;
        }
        return ret;
    }

    void solve(){
        input();
        for(int i=0; i < N;i++){
            if(dfsn[i] == 0 ) tarzan(i); 
        }
        for(int i=0; i < N; i++){
            for(auto j : adj[i]){
                if(sn[i] != sn[j]) indegree[sn[j]]++;
            }
        }
        int ans =0;

        for(int i=0; i < SN; i++)
            if(indegree[i] == 0) ans++;
        
        if(ans != 1) {
            cout << "Confused\n";
            return;
        }

        for(int i=0; i < N; i++){
            if(indegree[sn[i]] ==0 ) cout << i << "\n";
        }
    }
};


void solve(){
    FieldPlan FP;
    int T; cin >> T;
    for(int t= 0; t < T; t++){
        FP.solve();
        if(t<T-1)
            cout << '\n';
    }
}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _2152ë²ˆ: ì—¬í–‰ ê³„íš ì„¸ìš°ê¸°_  ğŸ˜¡ğŸ˜¡ğŸ˜¡ğŸ˜¡ğŸ˜¡

SCC + ìœ„ìƒì •ë ¬ 

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
typedef tuple<int,int> tii;
typedef tuple<int,int,int> tiii;
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.27 Wed
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX = 100001;
int N,M,start,target;
int dfsn[MAX],finished[MAX],sn[MAX],SN=0,cnt=0;
vector<int> adj[MAX];
stack<int> stk;

int tarzan(int curr){
    stk.push(curr);
    int ret = dfsn[curr] = ++cnt;
    for(auto next : adj[curr]){
        if(dfsn[next] == 0) ret = min(ret, tarzan(next));
        else if(finished[next] == 0) ret= min(ret,dfsn[next]);
    }

    if(ret == dfsn[curr]){
        while(1){
            int t= stk.top(); stk.pop();
            sn[t] = SN;
            finished[t] = true;
            if(curr==t) break;
        }
        SN++;
    }
    return ret;
}


vector<int> sAdj[MAX];
int sStart,sTarget;
int sMax[MAX],sCities[MAX],sOutdegree[MAX];
bool sVi[MAX];

void sccInfo(){
    for(int i=0; i < N; i++){
        int si = sn[i];
        sCities[si] += 1;
        if(i == target) sTarget = si;
        if(i == start) sStart = si;

        for(int j : adj[i]){
            int sj = sn[j];
            if(si == sj) continue;
            sAdj[si].push_back(sj);
            sOutdegree[sj]++;
        }
    }
}

void topoSort(){
    queue<int> q;
    for(int i=0; i < SN; i++){
        sMax[i] = sCities[i];
        if(i == sStart) sVi[i] = true;
        if(sOutdegree[i] == 0) q.push(i);
    }

    while(q.size()){
        int curr= q.front(); q.pop();
        for(auto next: sAdj[curr]){
            if(sVi[curr]){
                sMax[next] = max(sMax[next],sMax[curr]+sCities[next]);
                sVi[next] =true;
            }
            sOutdegree[next]--;
            if(sOutdegree[next] == 0) q.push(next);
        }
    }


}


void solve(){
    cin >> N >> M >> start>> target; start--;target--;
    for(int i=0; i < M ;i++){
        int u,v; cin >> u >> v; u--;v--;
        adj[u].push_back(v);
    }
    for(int i=0; i < N; i++){
        if(dfsn[i] == 0) tarzan(i);
    }
    
    sccInfo();
    topoSort();

    sVi[sTarget] ? cout << sMax[sTarget] : cout << 0;

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _4013ë²ˆ: ATM_ ğŸ˜¡ğŸ˜¡ğŸ˜¡ğŸ˜¡ğŸ˜¡

SCC + ìœ„ìƒì •ë ¬  2

ì¦~ë§ë¹¢ì„ë„¤ìœ ì´ê±°

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
typedef pair<int,int> pii;
typedef tuple<int,int,int> tiii;
#define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.27 Wed
    comment: 
    scc + topological sorting
    ë’¤ì§€ê²Œ ì–´ë µë„¹..
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX= 500001;
int N,M,start,K,cnt=0,SN=0;
int sn[MAX],rest[MAX],atm[MAX],dfsn[MAX],finished[MAX];
vector<int> adj[MAX];
int sStart,sAtm[MAX],sOutdegree[MAX],sRest[MAX];
vector<int> sAdj[MAX];
// sStart : ì‹œì‘ì ì„ í¬í•¨í•˜ëŠ” SCCë²ˆí˜¸
// sAtm : ì´ SCCì˜ í˜„ê¸ˆ ì•¡ìˆ˜ ì´í•©
// sOutdegree : ì´ SCCì˜ outdegree
// sRest : ì´ SCCê°€ ë ˆìŠ¤í† ë‘ì„ í¬í•¨í•˜ëŠ”ì§€
// sAdj : ì´ SCCì™€ ì¸ì ‘í•œ SCCë“¤ì„ ë‹´ê³  ìˆëŠ” ë¦¬ìŠ¤íŠ¸ã„´
stack<int> stk;

int tarzan(int curr){

    stk.push(curr);
    int ret = dfsn[curr] = ++cnt;
    for(auto next : adj[curr]){
        if(dfsn[next] ==0) ret =min(ret,tarzan(next));
        else if(finished[next] == 0) ret= min(ret,dfsn[next]);
    }

    if(ret == dfsn[curr]){

        while(1){
            int t = stk.top(); stk.pop();
            sn[t] = SN;
            finished[t] = true;
            if(t == curr) break;
        }
        SN++;
    }
    return ret;
}

int sMax[MAX]; // ê° SCCì˜ ê²°ê³¼ê°’
bool sCal[MAX]; // ì‹œì‘ì ì—ì„œ ì´ SCCë¡œ ë„ë‹¬í•  ìˆ˜ ìˆëŠ”ê°€?
void topoSort(){
    // SCC ë‹¨ìœ„ë¡œ ìœ„ìƒì •ë ¬ ì¤€ë¹„
    queue<int> Q;
    for(int i=0; i < SN; i++){
        sMax[i] = sAtm[i];// ê²°ê³¼ê°’ ì´ˆê¸°í™”: ìì‹ ì˜ ì•¡ìˆ˜ë§Œí¼ì€ ì±„ê¸¸ ìˆ˜ ìˆìŒ.
        if(i == sStart) sCal[i] = true;
        if(sOutdegree[i] == 0) Q.push(i); // outdegreeê°€ 0ì¸ SCCë¥¼ íì— ë„£ìŒ
    }

    // ìœ„ìƒì •ë ¬ ì‹œì‘

    while(Q.size()){
        int curr= Q.front(); Q.pop();
        for(auto next : sAdj[curr]){
            if(sCal[curr]){ // ì‹œì‘ì ì—ì„œ ì´ SCCì— ë„ë‹¬ ê°€ëŠ¥í•´ì•¼ë§Œ nextì˜ ì •ë³´ ê°±ì‹ 
                sMax[next] = max(sMax[next], sMax[curr] + sAtm[next]);
                sCal[next] = true;
            }
            sOutdegree[next]--;
            if(sOutdegree[next]==0) Q.push(next);
        }
    }

}

void sccInfo(){
    for(int i=0; i < N; i++){
        int si = sn[i];
        sAtm[si] += atm[i];
        if(rest[i]) sRest[si] = true;
        if(i== start) sStart = si;

        // sAdjë¥¼ ì±„ì›€
        for(int j : adj[i]){
            int sj = sn[j];
            if(si == sj) continue;
            // i,j ê°€ ì„œë¡œ ë‹¤ë¥¸ SCCì— í¬í•¨ë ë•Œë§Œ ê°„ì„  ìƒì„±
            sAdj[si].push_back(sj);
            sOutdegree[sj]++;
        }
    }
}


void solve(){
    cin >> N>> M;
    for(int i=0; i < M; i++){
        int u,v; cin >> u >> v; u--;v--;
        adj[u].push_back(v);
    }
    for(int i=0; i < N; i++){
        cin >> atm[i];
    }
    cin >> start >> K; start--;
    for(int i=0; i < K; i++){
        int a; cin >> a; a--;
        rest[a] = true;
    }

    for(int i=0; i < N; i++){
        if(dfsn[i] == 0) tarzan(i);
    }

    sccInfo();
    topoSort();

    int res =0;
    for(int i=0; i < SN; i++)
        if(sRest[i] && sCal[i]) res = max(res,sMax[i]);
    
    cout << res;



}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 