# ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬(Segment Tree)

https://blog.naver.com/PostView.nhn?blogId=kks227&logNo=220791986409&parentCategoryNo=&categoryNo=299&viewDate=&isShowPopularPosts=false&from=postView

### ì´ë¡ 

```

êµ¬ê°„ë“¤ì„ ë³´ì¡´í•˜ê³  ìˆëŠ” íŠ¸ë¦¬ë‹¤.

ë³´í†µì€ ì™„ì „ ì´ì§„íŠ¸ë¦¬ì˜ í˜•íƒœë¥¼ ì‚¬ìš©í•œë‹¤.
ê°’ì˜ ê°œìˆ˜ê°€ 2^nê¼´ì´ ì•„ë‹ ë•Œ ë‚¨ëŠ” êµ¬ê°„ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì±„ì›Œë„£ì–´
í¬í™”ì´ì§„íŠ¸ë¦¬í˜•íƒœë¡œ ë§ì´ ì“´ë‹¤.

ì´ë ‡ê²Œ í•˜ë©´ ê°’ì´ nê°œì¼ ë•Œ ë°˜ë“œì‹œ íŠ¸ë¦¬ì˜ ë†’ì´ê°€ O(logN)ìœ¼ë¡œ ê· í˜•ì¡íˆê¸° ë•Œë¬¸ì´ë‹¤.

í™ë•Œì™€ ë¹„ìŠ·í•˜ê²Œ ë£¨íŠ¸ê°€ ì¸ë±ìŠ¤1ë¶€í„° ì‹œì‘ë˜ë©°
ë ˆë²¨ì˜¤ë” ìˆœë²ˆìœ¼ë¡œ ë…¸ë“œë²ˆí˜¸ë¥¼ ë§¤ê²¨ì„œ ì ‘ê·¼í•˜ê¸° ì‰½ê²Œí•œë‹¤.

ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ëŠ” êµ¬ê°„ì •ë³´ë¡œ ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ì•„ë¬´ ê°’ì´ë‚˜ ì €ì¥í•´ë‘ëŠ”ë°,
ëŒ€í‘œì ìœ¼ë¡œ êµ¬ê°„ í•©, êµ¬ê°„ ê³±, êµ¬ê°„ ìµœëŒ“ê°’, êµ¬ê°„ ìµœì†Ÿê°’ ë“±ì´ ìˆë‹¤.

êµ¬ê°„ í•©ì„ ì–´ë–»ê²Œ êµ¬í• ê¹Œ?

ë¨¼ì € ë£¨íŠ¸ë¶€í„° ë‚´ë ¤ê°€ë©´ì„œ, êµ¬í•˜ë ¤ëŠ” êµ¬ê°„ì— ì´ ë…¸ë“œê°€ ì™„ì „íˆ í¬í•¨ë˜ë©´
ìì‹ ì˜ ê°’ì„ ë¦¬í„´í•˜ê³ , ì•„ë‹ˆë©´ êµ¬ê°„ì„ ì–‘ìª½ìœ¼ë¡œ ìª¼ê°œì„œ ê°ê° ì¬ê·€í˜¸ì¶œí•´ ë‘ í•¨ìˆ˜ì˜
ê²°ê³¼ê°’ì„ ë”í•œë‹¤.

ë§Œì•½ ì´ ë…¸ë“œì˜ êµ¬ê°„ì´ ëª©í‘œ êµ¬ê°„ê³¼ ì „í˜€ ê²¹ì¹˜ì§€ ì•Šìœ¼ë©´ ê·¸ëƒ¥ ì¢…ë£Œí•´ë²„ë¦¬ë©´ ëœë‹¤.


                            [0,7]
                     â”Œ--------â”´-------â”
                    [0,3]            [4,7]
                â”Œ----â”´â”               â”Œâ”´------â”
              [0,1]  [2,3]           [4,5]  [6,7]
           â”Œ---â”´â”    â”Œ-â”´--â”         â”Œ--â”´--â”   â”Œâ”´-----â”
        [0,0] [1,1] [2,2] [3,3]  [4,4] [5,5] [6,6] [7,7]


        
ì´ëŸ° ê·¸ë˜í”„ê°€ ìˆë‹¤ê³  í•˜ì.
êµ¬ê°„ [L,R]ì—ì„œ ëª©í‘œ êµ¬ê°„ì— ì†í•˜ëŠ” ì›ì†Œë“¤ì˜ í•©ì„ êµ¬í•œëŠ í•¨ìˆ˜ë¥¼ sum(L,R)ì´ë¼ê³  í•˜ì.
ìš°ë¦¬ê°€ ëª©í‘œë¡œ í•˜ëŠ” êµ¬ê°„ì´ [2,7]ì´ë¼ê³  í•˜ë©´,
ë§¨ ì²˜ìŒì—” ë£¨íŠ¸ì¸[0,7]ì—ì„œ ë¶€í„° ì‹œì‘í•œë‹¤. ì¦‰, sum(0,7)ì„ ë¶ˆëŸ¬ì„œ ì‹œì‘í•œë‹¤.
í˜¸ì¶œëœ sum(0,7)ì€ ì´ëŸ° í–‰ë™ì„ í•œë‹¤. [0,7]dl [2,7]ì— í¬í•¨ë˜ì§€ ì•Šì€ êµ¬ê°„ì´ë¯€ë¡œ
ì–‘ë¶„í•´ [0,3], [4,7]ë¡œ ë‚˜ëˆ„ì–´ì„œ ê°ê°ì„ ì¬ê·€í˜¸ì¶œí•´ ê·¸ ê²°ê³¼ë¥¼ ë”í•˜ê²Œí•œë‹¤.
sum(0,3)ì€ ë§ˆì°¬ê°€ì§€ë¡œ sum(0,1)ê³¼ sum(2,3)ì„ ë¶€ë¥¸ë‹¤.
sum(0,1)ì€ ëª©í‘œêµ¬ê°„[2,7]ê³¼ ê²¹ì¹˜ëŠ” êµ¬ê°„ì´ ì „í˜€ ì—†ìœ¼ë¯€ë¡œ 0ì„ ë¦¬í„´í•˜ë©° ì¢…ë£Œí•œë‹¤.
sum(2,3)ì€ ëª©í‘œêµ¬ê°„ [2,7]ì— ì™„ì „íˆ í¬í•¨ë˜ë¯€ë¡œ ìì‹ ì˜ ê°’ 4ë¥¼ ë¦¬í„´í•œë‹¤.
sum(0,3)ì€ ë”°ë¼ì„œ 0+4 = 4ë¥¼ ë¦¬í„´í•œë‹¤.
sum(4,7)ë˜í•œ [2,7]ì— ì™„ì „íˆ í¬í•¨ë˜ë¯€ë¡œ ë°”ë¡œ 5ë¥¼ ë¦¬í„´í•œë‹¤.
ìµœì¢…ì ìœ¼ë¡œ sum(0,7) = sum(0,3) + sum(4,7) = 4+5 = 9 ê°€ ëœë‹¤.



ëŒ€ì¶© ì´ëŸ°ì‹ìœ¼ë¡œ í•©ì„ êµ¬í•œë‹¤

sumí•¨ìˆ˜?


int sum(int L, int R, int nodeNum, int nodeL, int nodeR){
        if(R < nodeL || nodeR < L) return 0;
        if(L <= nodeL && nodeR <= R) return arr[nodeNum];
        int mid = (nodeL + nodeR) / 2;
        return sum(L, R, nodeNum*2, nodeL, mid) + sum(L, R, nodeNum*2+1, mid+1, nodeR);
}

nodeNumì€ í˜„ì¬ ë…¸ë“œì˜ ë²ˆí˜¸(ì¸ë±ìŠ¤)ê³  nodeLê³¼ nodeRì€ ê·¸ ë…¸ë“œê°€ í¬í•¨í•˜ëŠ” êµ¬ê°„ì„ ì˜ë¯¸í•œë‹¤.
Lê³¼ Rì€ ì‚¬ìš©ìê°€ êµ¬í•˜ê³ ì í•˜ëŠ” êµ¬ê°„ì´ë‹¤.
ë”°ë¼ì„œ êµ¬ê°„ [L,R]ì˜ í•©ì„ êµ¬í•˜ê³  ì‹¶ì„ ë•ŒëŠ” ì²˜ìŒì— sum(L,R,1,0,N-1)ì„ í˜¸ì¶œí•´ì•¼í•œë‹¤.
Nì€ ê°’ì˜ ê°œìˆ˜,([0,N]) ë£¨íŠ¸ë²ˆí˜¸ëŠ” 1ì´ë‹¤.

sumí•¨ìˆ˜ì˜ ì²«ë²ˆì§¸ ì¤„ì€[nodeL,nodeR]ê³¼ [L,R]ì´ ì „í˜€ ì•ˆê²¹ì¹˜ëŠ” ê²½ìš°, ë°”ë¡œ 0ì„ ë¦¬í„´í•œë‹¤.
ë‘ë²ˆì§¸ ì¤„ì€[nodeL,nodeR]ì´ [L,R]ì— ì™„ì „íˆ í¬í•¨ë˜ëŠ” ê²½ìš°, ìì‹ ì˜ ê°’ì„ ë¦¬í„´í•œë‹¤.
3~4ë²ˆì§¸ ì¤„ì€ ê·¸ ì™¸ì˜ ê²½ìš°ë¡œ í˜„ì¬ ë…¸ë“œì˜ êµ¬ê°„ì„ ì–‘ë¶„í•´ ê°ê°ì„ ì¬ê·€í˜¸ì¶œí•´ì„œ ë”í•œë‹¤. 
ì´ê±´ ì´ êµ¬ê°„ì„ 2ë“±ë¶„í•˜ë©´ ì™¼ìª½ì€ ì´ë…¸ë“œì˜ ì™¼ìª½ìì‹, ì˜¤ë¥¸ìª½ì€ ì´ ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ ìì‹ì´ í‘œí˜„í•˜ê³  ìˆë‹¤ëŠ”ê±¸ ì˜ ì´ìš©í•œ í˜•íƒœë‹¤.
[L,R]ì´ ì•„ë‹ˆë¼ [L,R)ë¡œ ì§œë„ ëœë‹¤.

sumí•¨ìˆ˜ì˜ ì‹œê°„ë³µì¡ë„? O(logN)
ì´ëŠ” íŠ¸ë¦¬ì˜ ë†’ì´ê°€ O(logN)ì´ë¼ì„œ ìµœëŒ€ ê·¸ë§Œí¼ì˜ ì—°ì‚°ì„ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
ìµœì•…ì˜ ê²½ìš°ì˜ ì¬ê·€í˜¸ì¶œìˆ˜ëŠ” 2*logNì´ë‹¤.
ìµœëŒ€í•œ ì¬ê·€í˜¸ì¶œì´ ë§ì´ ë˜ë„ë¡í•˜ì—¬ë„ í•˜ë‚˜ì˜ ê¹Šì´ì—ì„œ 3ê°œì´ìƒì˜ í˜¸ì¶œì€ ê°€ëŠ¥í•˜ì§€ ì•Šë‹¤.
ì™œëƒë©´ ëª¨ë‘ í¬í•¨í•˜ëŠ” ìƒìœ„ë…¸ë“œê°€ ì—„ë°€íˆ ì¡´ì¬í•˜ê³ ìˆê¸° ë•Œë¬¸ì´ë‹¤.(ìª¼ê°œì§ˆ ë•Œ ìµœëŒ€ 2ê°œì”© ìª¼ê°œì§„ë‹¤)


updateí•¨ìˆ˜?

ë§Œì•½ ì–´ë–¤ ê°’ì„ ìƒˆë¡œìš´ ê°’ìœ¼ë¡œ ë°”ê¾¸ë ¤ê³  í•œë‹¤ë©´,
ë¦¬í”„ë…¸ë“œê¹Œì§€ ê°€ì„œ ê·¸ ê°’ì„ ë°”ê¿”ì•¼ í•  ê²ƒì´ë‹¤.
ê·¸ëŸ¼ ê·¸ì— ì˜í–¥ì„ ë°›ëŠ” ë…¸ë“œë“¤ì€ ê·¸ ìƒìœ„ ë…¸ë“œ, ì¦‰ logNê°œì˜ ë…¸ë“œë“¤ì˜ ê°’ì´ ë°”ë€ë‹¤.
ê·¸ëŸ¬ë¯€ë¡œ ê°±ì‹ ì— í•„ìš”í•œ ì‹œê°„ì´O(logN)ì´ ëœë‹¤.

ì›ì†Œ ê°’ì„ ë°”ê¾¸ëŠ” ì—°ì‚°, êµ¬ê°„ í•©ì„ êµ¬í•˜ëŠ” ì—°ì‚° ë‘˜ ë‹¤ ì‹œê°„ë³µì¡ë„ê°€ O(logN)ì´ë¯€ë¡œ,
ê°’ ê°œìˆ˜ Nê³¼ ì¿¼ë¦¬ê°œìˆ˜ Qê°€ ì£¼ì–´ì¡Œì„ë•Œ ì‹œê°„ë³µì¡ë„ëŠ” O(QlogN)ì´ëœë‹¤.


void update(int i, int val){
    i += size;
    arr[i] = val;
    while(i > 1){
        i /= 2;
        arr[i] = arr[i*2] + arr[i*2+1];
    }
}

ië²ˆì§¸ ì›ì†Œë¥¼ valë¡œ ê°±ì‹ í•˜ë¼.
ë¨¼ì € í•´ë‹¹ì›ì†Œê°€ ì„¸ê·¸íŠ¸ë¦¬ì— ì§„ì§œ ìˆëŠ” ë…¸ë“œë²ˆí˜¸ì¸ì§€ í™•ì¸í•´ì•¼í•œë‹¤.
ì´ ì½”ë“œì—ì„œëŠ” sizeê°€ ê°’ì˜ ê°œìˆ˜(2^kê¼´)ë¼ ê°€ì •í–ˆì„ ê²½ìš°ê³  ê·¸ë ‡ë‹¤ë©´ sizeë¥¼ ë”í•´ì£¼ë©´ ê·¸ ì¸ë±ìŠ¤ê°€ ëœë‹¤.
ì´ë ‡ê²Œ ì‹œì‘í•´ì„œ iê°€ ë£¨íŠ¸ì— ë‹¤ë‹¤ë¥¼ë•Œê¹Œì§€ ì°¨ë¡€ëŒ€ë¡œ ë¶€ëª¨ë¥¼ ë°©ë¬¸í•´ê°€ë©° ê°’ë“¤ì„ ê°±ì‹ ì‹œí‚¨ë‹¤.

void construct(){
    for(int i = MAX_ST/2-1; i > 0; --i)
        arr[i] = arr[i*2] + arr[i*2+1];
}

êµ¬ì¶•(construct) ì—°ì‚°

ë¦¬í”„ ë…¸ë“œë“¤ì˜ ê°’ì„ ë¯¸ë¦¬ ì¤€ í›„, ì´ ê°’ë“¤ë¡œ ì„¸ê·¸íŠ¸ë¦¬ë¥¼ êµ¬ì¶•í•œë‹¤.
ì¸ë±ìŠ¤ [MAX_ST/2, MAX_ST)ì— ë¦¬í”„ë…¸ë“œë“¤ì˜ ê°’ì´ ìˆë‹¤ê³  í•  ë•Œ, 
ê·¸ ë°”ë¡œ ìœ„ ë…¸ë“œë“¤ë¶€í„° ì¸ë±ìŠ¤ê°€ ê°ì†Œí•˜ëŠ” ìˆœìœ¼ë¡œ ë°°ì—´ì˜ ê°’ì„ êµ¬í•œë‹¤.
ê°’ì„ êµ¬í•  ë•Œ ìì‹ ì˜ ë‘ ìì‹ì˜ ë°°ì—´ ê°’ì„ ë”í•´ì•¼í•˜ëŠ”ë°,
ì¸ë±ìŠ¤ê°€ ê°ì†Œí•˜ëŠ” ìˆœìœ¼ë¡œ êµ¬í•˜ë©´ í•­ìƒ ì œëŒ€ë¡œ ëœ ê°’ì„ êµ¬í•  ìˆ˜ ìˆë‹¤.

ê° ë…¸ë“œë¥¼ í•œë²ˆ ì”©ë§Œ ë³´ë‹ˆê¹Œ O(N)ë§Œì— ì„¸ê·¸íŠ¸ë¦¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

ê·¸ëƒ¥ ë¦¬í”„ë…¸ë“œ í•˜ë‚˜í•˜ë‚˜ updateí•œë‹¤ë©´ O(NlogN)ì˜ ì‹œê°„ì´ ê±¸ë¦°ë‹¤.





```


### ë¬¸ì œ

* [2042ë²ˆ: êµ¬ê°„ í•© êµ¬í•˜ê¸°](https://www.acmicpc.net/problem/2042)
* [11505ë²ˆ: êµ¬ê°„ ê³± êµ¬í•˜ê¸°](https://www.acmicpc.net/problem/11505)
* [2357ë²ˆ: ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’](https://www.acmicpc.net/problem/2357)
* [12837ë²ˆ: ê°€ê³„ë¶€ (Hard)](https://www.acmicpc.net/problem/12837)
* [12015ë²ˆ: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 2](https://www.acmicpc.net/problem/12015)
* [1275ë²ˆ: ì»¤í”¼ìˆ2](https://www.acmicpc.net/problem/1275)
* [2268ë²ˆ: ìˆ˜ë“¤ì˜ í•©](https://www.acmicpc.net/problem/2268)
* [3745ë²ˆ: ì˜¤ë¦„ì„¸](https://www.acmicpc.net/problem/3745)
* [1365ë²ˆ: ê¼¬ì¸ ì „ê¹ƒì¤„](https://www.acmicpc.net/problem/1365)
* [3006ë²ˆ: í„°ë³´ì†ŒíŠ¸](https://www.acmicpc.net/problem/3006)
* [1280ë²ˆ: ë‚˜ë¬´ ì‹¬ê¸° (â˜…)](https://www.acmicpc.net/problem/1280)
* [3653ë²ˆ: ì˜í™” ìˆ˜ì§‘ (â˜…)](https://www.acmicpc.net/problem/3653)
* [9345ë²ˆ: ë””ì§€í„¸ ë¹„ë””ì˜¤ ë””ìŠ¤í¬ (â˜…)](https://www.acmicpc.net/problem/9345)
* [2243ë²ˆ: ì‚¬íƒ•ìƒì (â˜…)](https://www.acmicpc.net/problem/2243)
* [2336ë²ˆ: êµ‰ì¥í•œ í•™ìƒ (â˜…)](https://www.acmicpc.net/problem/2336)

<!-- 

***

<details>

<summary>

#### _3006ë²ˆ: í„°ë³´ì†ŒíŠ¸_

</summary>

```cpp

```

</details> 


-->

***

<details>

<summary>

#### _2042ë²ˆ: êµ¬ê°„ í•© êµ¬í•˜ê¸°_

ì„¸ê·¸íŠ¸ë¦¬ ê¸°ë³¸ë¬¸ì œ

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
#define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

int n,m,k;
const int MAX = 1e6+2;
// ì„¸ê·¸ ë°°ì—´ ,*4ì •ë„ë¡œ ë„‰ë„‰í•˜ê²Œ ì¡ëŠ”ë‹¤.
int seg[MAX*4];
// arrë°°ì—´, ì…ë ¥ê°’ì„ ë°›ëŠ”ë‹¤.
int arr[MAX];


// ì„¸ê·¸êµ¬ì¡°ì²´
struct Segtree{

    // constructí•¨ìˆ˜, ì„¸ê·¸íŠ¸ë¦¬ë¥¼ êµ¬ì¶•í•œë‹¤
    int construct(int l, int r ,int curIdx){
        // ê¸°ì €ì‚¬ë¡€: left ì™€ rightê°€ ê°™ë‹¤ë©´ seg[curIdx] = arr[l]ì„ ë°˜í™˜
        if(l == r) return seg[curIdx] = arr[l];
        int mid = (l+r)/2;
        // ì–‘ë¶„í•˜ë©° ë‚´ë ¤ê°„ë‹¤
        // seg[curIdx] = ì™¼ìª½ì˜ í•© + ì˜¤ë¥¸ìª½ í•©
        return seg[curIdx] = construct(l,mid,curIdx*2) + construct(mid+1,r,curIdx*2+1);
    }

    // queryí•¨ìˆ˜, í•„ìš”í•œ ì¿¼ë¦¬ë¥¼ ë°˜í™˜í•œë‹¤.
    // l,r : ë‚´ê°€ ì›í•˜ëŠ” êµ¬ê°„ì˜ ì¿¼ë¦¬
    // curIdx: í˜„ì¬ ë…¸ë“œì˜ ì¸ë±ìŠ¤
    // nodeL,nodeR : í˜„ì¬ ë…¸ë“œê°€ ê°–ê³ ìˆëŠ” êµ¬ê°„ì˜ left,right
    int query(int l, int r, int curIdx, int nodeL, int nodeR){
        // ë§Œì•½ í˜„ì¬ë…¸ë“œì˜ ì™¼ìª½êµ¬ê°„ì´ êµ¬í•˜ë ¤ëŠ” ì˜¤ë¥¸ìª½êµ¬ê°„ë³´ë‹¤ í¬ê±°ë‚˜
        // í˜„ì¬ë…¸ë“œì˜ ì˜¤ë¥¸ìª½êµ¬ê°„ì´ êµ¬í•˜ë ¤ëŠ” ì™¼ìª½êµ¬ê°„ë³´ë‹¤ ì‘ìœ¼ë©´
        // í¬í•¨ë˜ì§€ì•ŠëŠ” êµ¬ê°„ì´ë¯€ë¡œ 0ì„ ë°˜í™˜í•œë‹¤.
        if( nodeL > r || nodeR < l) return 0;

        // ë§Œì•½ ë‚´ê°€ êµ¬í•˜ë ¤ëŠ” êµ¬ê°„ l,r ëª¨ë‘ê°€ í˜„ì¬ë…¸ë“œl,rì•ˆì— ì†í•œë‹¤ë©´ ê·¸ ê°’ì„ ë°˜í™˜í•œë‹¤.
        if(l <= nodeL && nodeR <= r) return seg[curIdx];

        // ì–‘ë¶„í•˜ë©° ë‚´ë ¤ê°„ë‹¤.
        int mid = (nodeL + nodeR) /2;
        // ì™¼ìª½ë¶€ë¶„ì˜ í•© + ì˜¤ë¥¸ìª½ ë¶€ë¶„ì˜ í•©ì„ ë°˜í™˜í•œë‹¤.
        return query(l,r,curIdx*2,nodeL,mid) + query(l,r,curIdx*2+1,mid+1,nodeR);
    }

    // update í•¨ìˆ˜, ì–´ë– í•œ ê°’ì„ ìƒˆë¡œìš´ ê°’ìœ¼ë¡œ ë°”ê¾¼ë‹¤.
    // updateIdx, newVal -> updateIdxì—ìˆëŠ” ê°’ì„ newValë¡œ ë°”ê¾¼ë‹¤.
    // curIdx, nodeL,nodeR -> í˜„ì¬ ê°€ë¦¬í‚¤ëŠ” ë…¸ë“œ curIdxì™€ ê·¸ ë…¸ë“œì˜ ì™¼ìª½êµ¬ê°„ nodeL, ì˜¤ë¥¸ìª½êµ¬ê°„ nodeR
    int update(int updateIdx, int newVal, int curIdx, int nodeL, int nodeR){
        // ë§Œì•½ ê°’ì„ ìƒˆë¡œ ë„£ìœ¼ë ¤ëŠ” idxê°€ í˜„ì¬ ê°€ë¥´í‚¤ëŠ” nodeì˜ ì™¼ìª½êµ¬ê°„ ë³´ë‹¤ ì ê±°ë‚˜ ì˜¤ë¥¸ìª½êµ¬ê°„ë³´ë‹¤ í¬ë©´ segë°°ì—´ì˜ í˜„ì¬ê°’ì„ ë°˜í™˜í•œë‹¤.
        if( updateIdx < nodeL || updateIdx > nodeR) return seg[curIdx];
        // ë§Œì•½ í˜„ì¬ ë…¸ë“œì˜ ì™¼ìª½êµ¬ê°„ê³¼ ì˜¤ë¥¸ìª½êµ¬ê°„ì´ ê°™ë‹¤ë©´ (ë¦¬í”„ë…¸ë“œì— ë„ë‹¬í–ˆë‹¤ë©´) segë°°ì—´ì˜ í˜„ì¬ì¸ë±ìŠ¤ë¥¼ ìƒˆë¡œìš´ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•œë‹¤.
        if(nodeL == nodeR) return seg[curIdx] = newVal;

        // ì–‘ë¶„í•˜ë©° ë‚´ë ¤ê°„ë‹¤.
        int mid = (nodeL + nodeR) /2;
        // ì„¸ê·¸ë°°ì—´ì˜ í˜„ì¬ì¸ë±ìŠ¤ë¥¼ ìƒˆë¡œìš´ ì™¼ìª½ë¶€ë¶„ì˜ í•©+ ì˜¤ë¥¸ìª½ë¶€ë¶„ì˜ í•©ìœ¼ë¡œ ê°±ì‹ í•œë‹¤.
        return seg[curIdx] = update(updateIdx, newVal, curIdx*2, nodeL, mid)+ update(updateIdx,newVal,curIdx*2+1,mid+1,nodeR);

    }
};

void solve(){
    cin >> n >> m>> k;
    Segtree ST;

    for(int i=1; i<= n; i++){
        int a; cin >> a;
        arr[i] =a;
    }
    // 1ë¶€í„° nê¹Œì§€ êµ¬ì¶•í•œë‹¤.
    ST.construct(1,n,1);

    for(int i=1; i<= m+k; i++){
        int a,b,c; cin >> a >> b>> c;
        if(a==1){
            ST.update(b,c,1,1,n);
        }else{
            cout << ST.query(b,c,1,1,n) << '\n';
        }

    }


}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _11505ë²ˆ: êµ¬ê°„ ê³± êµ¬í•˜ê¸°_

ì„¸ê·¸íŠ¸ë¦¬ ê¸°ë³¸ë¬¸ì œ 2

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
#define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    ì„¸ê·¸íŠ¸ë¦¬ êµ¬ê°„ê³±
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX = 1000001, MOD = 1000000007;

int arr[MAX], seg[MAX*4], N,M,K;


struct SegTree{

    int construct(int node, int nodeL, int nodeR){
        if(nodeL == nodeR) return seg[node] = arr[nodeL];
        int mid= (nodeL+nodeR)/2;
        return seg[node] = (construct(node*2,nodeL, mid) * construct(node*2+1,mid+1,nodeR))%MOD;
    }
    int query(int l, int r, int node, int nodeL, int nodeR){
        if(l > nodeR || r < nodeL) return 1;
        if(l <= nodeL && r >= nodeR) return seg[node];
        
        int mid = (nodeL+nodeR)/2;
        return (query(l,r,node*2,nodeL,mid) * query(l,r,node*2+1,mid+1,nodeR))%MOD;
    }
    // ti = target idx, nv = new value
    int update(int ti, int nv, int node, int nodeL , int nodeR){
        if(ti < nodeL || ti > nodeR) return seg[node];
        if(nodeL == nodeR) return seg[node] = nv;

        int mid = (nodeL + nodeR) /2;

        return seg[node] = (update(ti,nv,node*2,nodeL,mid) * update(ti,nv,node*2+1,mid+1,nodeR))%MOD;

    }

};

void solve(){
    cin >> N >> M >> K;
    SegTree ST;
    for(int i=1; i <= N; i++){
        cin >> arr[i];
    }
    ST.construct(1,1,N);

    for(int i=0; i < M+K; i++){
        int a,b,c; cin >> a>> b>> c;

        if(a== 1){
            ST.update(b,c,1,1,N);
        }else{
            cout << ST.query(b,c,1,1,N) << '\n';
        }

    }


}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _2357ë²ˆ: ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’_

ì„¸ê·¸íŠ¸ë¦¬ ê¸°ë³¸ë¬¸ì œ 3
íŠ¸ë¦¬ë¥¼ ë‘ê°œì¨ì•¼í•œë‹¤

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX = 100001;

int segMin[MAX*4],segMax[MAX*4], arr[MAX],N,M;

struct SegTreeMin{
    int construct(int node, int nodeL, int nodeR){
        if(nodeL == nodeR) return segMin[node] = arr[nodeL];
        int mid = (nodeL + nodeR)/2;
        return segMin[node] = min(construct(node*2,nodeL,mid),construct(node*2+1,mid+1,nodeR));
    }
    int query(int l, int r, int node, int nodeL, int nodeR){
        if( l > nodeR || r < nodeL) return 1<<30;
        if(l <= nodeL && r >= nodeR) return segMin[node];
        int mid= (nodeL+nodeR)/2;
        return min(query(l,r,node*2,nodeL,mid),query(l,r,node*2+1,mid+1,nodeR));
    }
};

struct SegTreeMax{
    int construct(int node, int nodeL, int nodeR){
        if(nodeL == nodeR) return segMax[node] = arr[nodeL];
        int mid = (nodeL + nodeR)/2;
        return segMax[node] = max(construct(node*2,nodeL,mid),construct(node*2+1,mid+1,nodeR));
    }
    int query(int l, int r, int node, int nodeL, int nodeR){
        if( l > nodeR || r < nodeL) return -1;
        if(l <= nodeL && r >= nodeR) return segMax[node];
        int mid= (nodeL+nodeR)/2;
        return max(query(l,r,node*2,nodeL,mid),query(l,r,node*2+1,mid+1,nodeR));
    }
};

void solve(){

    cin >> N>> M;
    SegTreeMin STMIN;
    SegTreeMax STMAX;

    for(int i=1; i<= N; i++){
        cin >> arr[i];
    }
    STMIN.construct(1,1,N);
    STMAX.construct(1,1,N);
    for(int i=0; i< M; i++){
        int a,b; cin >> a >> b;
        cout << STMIN.query(a,b,1,1,N) << ' ' << STMAX.query(a,b,1,1,N) << '\n';
    }

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}



```

</details> 

***

<details>

<summary>

#### _12837ë²ˆ: ê°€ê³„ë¶€ (Hard)_

ì„¸ê·¸íŠ¸ë¦¬ ê¸°ë³¸ë¬¸ì œ 4
êµ¬ê°„í•©êµ¬í•˜ëŠ” ë¬¸ì œ

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
#define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX = 1000001;
int arr[MAX],seg[MAX*4],N,Q;

struct SegTree{

    int init(int node, int nodeL, int nodeR){
        if(nodeL == nodeR) return seg[node] = arr[nodeL];
        int mid = (nodeL+nodeR)/2;
        return seg[node] = init(node*2,nodeL,mid) + init(node*2+1,mid+1,nodeR);
    }

    int query(int l, int r, int node, int nodeL, int nodeR){
        if(l > nodeR || r < nodeL) return 0;
        if(l <= nodeL && r >= nodeR) return seg[node];
        int mid = (nodeL+nodeR) /2;
        return query(l,r,node*2,nodeL,mid) + query(l,r,node*2+1,mid+1,nodeR);
    }

    int update(int ti, int nv, int node ,int nodeL, int nodeR){
        if(ti <nodeL || ti > nodeR) return seg[node];
        if(nodeL == nodeR) return seg[node] += nv;
        int mid = (nodeL+nodeR)/2;
        return seg[node] = update(ti,nv,node*2,nodeL,mid) + update(ti,nv,node*2+1,mid+1,nodeR);
    }

};



void solve(){
    cin >> N >> Q;
    SegTree ST;
    ST.init(1,1,N);

    for(int i=0; i < Q;i++){
        int a,b,c; cin >>  a >> b >> c;
        if(a==1){
            ST.update(b,c,1,1,N);
        }else{
            cout << ST.query(b,c,1,1,N) << '\n';
        }
    }

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _12015ë²ˆ: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 2_

o(NlogN) lis

ì„¸ê·¸ë¡œ í’€ì–´ë³´ê¸°

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/


void solve(){
    int n; cin >> n;

    vector<int> v;
    v.push_back(-(1<<30)); int ans=0;
    for(int i=0; i < n; i++){
        int a; cin >> a;
        if(v.back() < a){
            v.push_back(a); ans++;
        }
        else{
            auto it= lower_bound(all(v),a);
            *it = a;
        }
    }
    cout << ans;


}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}


```

</details> 


***

<details>

<summary>

#### _1275ë²ˆ: ì»¤í”¼ìˆ2_

ì„¸ê·¸íŠ¸ë¦¬ ê¸°ë³¸ë¬¸ì œ 5

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
#define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    ì„¸ê·¸íŠ¸ë¦¬
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX =100001;
int seg[MAX*4],arr[MAX],N,Q;

struct SegTree{

    int init(int node, int nodeL, int nodeR){
        if(nodeL == nodeR) return seg[node] = arr[nodeL];
        int mid = (nodeL+nodeR)/2;
        return seg[node] = init(node*2, nodeL,mid) + init(node*2+1, mid+1,nodeR);
    }

    int query(int l, int r, int node, int nodeL, int nodeR){
        if(l > nodeR || r < nodeL) return 0;
        if(l <=nodeL && r >= nodeR) return seg[node];
        int mid = (nodeL+nodeR)/2;
        return query(l,r,node*2,nodeL,mid) + query(l,r,node*2+1,mid+1,nodeR);
    }

    int update(int ti, int nv, int node, int nodeL, int nodeR){
        if(ti < nodeL || ti > nodeR) return seg[node];
        if(nodeL == nodeR) return seg[node] = nv;
        int mid = (nodeL+nodeR)/2;
        return seg[node] = update(ti,nv,node*2,nodeL,mid) + update(ti,nv,node*2+1,mid+1,nodeR);
    }

};


void solve(){
    cin >> N >> Q;
    for(int i=1 ; i<= N; i++){
        cin >> arr[i];
    }
    SegTree ST;
    ST.init(1,1,N);

    for(int i=0; i< Q; i++){
        int x,y,a,b;
        cin >> x >> y >> a >> b;
        if(x > y) {
            swap(x,y);
        }
        cout << ST.query(x,y,1,1,N) << '\n';
        ST.update(a,b,1,1,N);
    }

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _2268ë²ˆ: ìˆ˜ë“¤ì˜ í•©_

ì„¸ê·¸íŠ¸ë¦¬ ê¸°ë³¸ë¬¸ì œ 6

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
#define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    ì„¸ê·¸íŠ¸ë¦¬ 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/

const int MAX = 1000001;
int seg[4*MAX],arr[MAX],N,M;

struct SegTree{
    int query(int l, int r, int node, int nodeL, int nodeR){
        if(l > nodeR || r < nodeL) return 0;
        if(l <= nodeL && r >= nodeR) return seg[node];
        int mid= (nodeL+nodeR)/2;
        return query(l,r,node*2,nodeL,mid) + query(l,r,node*2+1,mid+1,nodeR);
    }

    int update(int ti, int nv, int node, int nodeL , int nodeR){
        if(ti < nodeL  || ti > nodeR) return seg[node];
        if(nodeL == nodeR) return seg[node] = nv;
        int mid = (nodeL +nodeR)/2;
        return seg[node] = update(ti,nv,node*2,nodeL,mid) + update(ti,nv,node*2+1,mid+1,nodeR);
    }

};

void solve(){
    cin >> N >> M;
    SegTree ST;
    for(int i=0; i < M; i++){
        int a,b,c;
        cin >> a >> b >> c;
        if(a == 0 && b>c) swap(b,c);
        if(a == 1){
            ST.update(b,c,1,1,N);
        }else{
            cout << ST.query(b,c,1,1,N) << '\n';
        }
    }

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 


***

<details>

<summary>

#### _3745ë²ˆ: ì˜¤ë¦„ì„¸_

O(NlogN) lis 2

ì„¸ê·¸ë¡œ í’€ì–´ë³´ê¸°

</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/


void solve(){
    int n;
    while(cin >> n){

    vector<int> v;
    v.push_back(-(1<<30)); int ans=0;
    for(int i=0; i < n; i++){
        int a; cin >> a;
        if(v.back() < a){
            v.push_back(a); ans++;
        }
        else{
            auto it= lower_bound(all(v),a);
            *it = a;
        }
    }
    cout << ans << '\n';
    }

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 

***

<details>

<summary>

#### _1365ë²ˆ: ê¼¬ì¸ ì „ê¹ƒì¤„_

O(NlogN) lis 3

ì„¸ê·¸ë¡œ í’€ì–´ë³´ê¸°

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/


void solve(){
    int n;
    // while(cin >> n){
    cin >> n;
    vector<int> v;
    v.push_back(-(1<<30)); int ans=0;
    for(int i=0; i < n; i++){
        int a; cin >> a;
        if(v.back() < a){
            v.push_back(a); ans++;
        }
        else{
            auto it= lower_bound(all(v),a);
            *it = a;
        }
    }
    cout << n-ans << '\n';
    // }

}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 


***

<details>

<summary>

#### _3006ë²ˆ: í„°ë³´ì†ŒíŠ¸_ ğŸ˜¡ğŸ˜¡ğŸ˜¡

ë‹¤ì‹œí’€ì–´ë³´ê¸°

</summary>

```cpp

#include <bits/stdc++.h>
using namespace std;
#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define debug freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define o1 first
#define o2 second
#define pii pair<int,int>
// #define int int64_t
/* â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾
    2021.01.23 Sun
    comment: 
    

â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾ â½â½â—( Ë™ ê’³ Ë™ )â—œâ¾â¾*/
const int ST_MAX = 262144;

struct SegTree{
    int A[ST_MAX], start;
    SegTree(){
        fill(A, A+ST_MAX, 0);
        start = ST_MAX/2;
    }

    void update(int n){
        n += start;
        A[n] ++;
        while(n>1){
            n/=2;
            A[n]++;
        }
    }
    int cnt(int s, int e){
        return cnt(s,e,1,0,start);
    }

    int cnt(int s,int e, int node ,int ns, int ne){
        if(ne <= s || e <= ns) return 0;
        if(s <= ns && ne <= e) return A[node];
        int mid = (ns+ne) /2;
        return cnt(s,e,node*2,ns,mid) + cnt(s,e,node*2+1,mid,ne);
    }

};


void solve(){
    int N;
    cin >> N;
    pii p[100000];
    for(int i=0; i < N; i++){
        int val;
        cin >> val;
        p[i] = {val-1,i};
    }
    sort(p,p+N);
    SegTree ST;
    for(int i=0; i < N ; i++){
        int pos;
        if(i%2){
            pos = p[N-1-i/2].second;
            cout << N-1-pos-ST.cnt(pos,N) << '\n';
        }else{
            pos = p[i/2].second;
            cout << pos-ST.cnt(0,pos) << '\n';
        }
        ST.update(pos);
    }


}


int32_t main() {
    int t=1;
    fastio;
    // debug;
    {
        // cin >> t; 
        for(int i=1; i <= t; i++) solve();
    }
}

```

</details> 