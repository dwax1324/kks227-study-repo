# 투 포인터(Two Pointers Algorithm), 슬라이딩 윈도우(Sliding Window)

https://blog.naver.com/kks227/220795165570

### 이론


```

성향이 비슷한 알고리즘 2개,
첫번째로 투 포인터(two pointers)알고리즘
1차원 배열이 있고 이 배열에서 각자 다른 원소를 가리키고 2개의 포인터를 조작해가며 원하는 것을 얻는 형태다.


배열에서 구간합이 k인 갯수를 투포인터를 사용하여 해결했을때의 증명



현재 우리의 포인터가 [lo, hi)에 위치해 있고,

구간 합이 k인 구간 [L, H)가 하나 존재한다고 해봅시다. (합이 k인 구간을 세는 게 목표)

이때 우리가 앞으로 포인터를 이처럼 증가시키면 절대 [L, H) 구간을 만나지 않고 지나칠 수 없음을 보이면 됩니다.



만약이라도 그렇게 지나치려면 방법은 두 가지가 있는데요.

① hi = H가 되기 전에 lo > L이 된다.

그런데 이럴 수 없습니다. 포인터는 한 칸씩 증가하니까, 저렇게 지나가려면 최소한 lo = L인 시점이 한 번은 존재합니다.

그런데 hi < H이고 lo = L이라면 저 빨간 구간보다 현재 구간이 작고, 따라서 구간합이 k보다 작죠.

따라서 이 상황에서는 무조건 hi를 증가시킬 수밖에 없고, hi가 H까지 다다르기 전에는 증가를 멈추지도 못합니다!

② lo = L이 되기 전에 hi > H가 된다.

역시 이것도 안됩니다. 위와 아주 똑같이 논파할 수 있습니다.

hi가 H를 지나쳐 가려면 hi = H인 시점이 한 번은 존재하는데,

이 때 lo < L이라면 해당 구간의 합이 k보다 반드시 크기 때문에 여기서 hi를 증가시킬 수가 없습니다!



이것들은 모두 원소가 다 자연수이기 때문에 성립합니다.

이 증명을 보니 왜 원소가 자연수라는 조건이 붙었는지 아시겠죠.
[출처] 투 포인터(Two Pointers Algorithm), 슬라이딩 윈도우(Sliding Window) (수정: 2019-09-09)|작성자 라이



```